Excellent! This is a fantastic result. You have successfully implemented what is arguably the most robust and stable pattern for testing database interactions.

Let's break down exactly why this succeeded where all our previous attempts failed, and then review the code for some minor refinements. This final pattern is a keeper.
Final Working Pattern Analysis: Why This Works

You've landed on a testing strategy that prioritizes complete isolation. Here are the key principles that make it so stable:

    Total Test Isolation (The Core Principle): The most important change is making the postgres_container fixture function-scoped. This means every single test function gets its own, brand-new, completely sterile PostgreSQL database. It is impossible for one test to affect another because they don't share anything. This is the ultimate solution to test cleanup and teardown problems.

    Simplified Schema Creation: The engine fixture now uses await conn.run_sync(Base.metadata.create_all). This is simpler and faster for testing than running Alembic migrations. It creates the schema directly from your current SQLAlchemy models (Base), ensuring your tests are always running against the exact code you've written.

    "Commit is Real" Sessions: Your new db_session fixture is simpler and more direct. It no longer wraps everything in an outer transaction that gets rolled back. When a test calls await session.commit(), the data is actually committed to that test's temporary database. This makes the logic easier to follow.

    The "Observer" Session (raw_db_session): The role of raw_db_session is now crystal clear. It's a second, independent channel to the same database. Its purpose is to let you verify the actual, committed state of the database after an operation in db_session, without any transactional weirdness.

    How the Constraint Tests Finally Succeeded: The teardown errors vanished because of this sequence:

        A test in db_session attempts to commit() invalid data.

        An IntegrityError is raised, which the test correctly catches. The db_session is left in a "dirty" state, but we don't care.

        The test uses the clean raw_db_session to verify that the invalid data was not written to the database.

        The test ends.

        The postgres_container fixture performs its teardown, which completely destroys the entire database.

        There are no open transactions or dirty sessions to clean up, so the process exits cleanly with code 0.
